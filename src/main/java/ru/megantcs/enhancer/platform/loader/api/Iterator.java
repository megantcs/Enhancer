package ru.megantcs.enhancer.platform.loader.api;

/**
 * Интерфейс для двух направленного итерирования по тексту
 * предоставляет возможность перемещаться по тексту
 * вперед и назад.
 * Предназначен для последовательной обработки
 * содержимого текста
 *
 * <p>Пример использование:<p/>
 * <pre>{@code
 * Iterator iterator = YourIteratorRealization(yourContent);
 * while(iterator.next()) {
 *     var cur = iterator.peek();
 *     // работа с cur...
 * }
 * }<pre/>
 */
public interface Iterator<IteratorType>
{
    /**
     * Переходит на следующий элемент
     *
     * @return {@code true} есть следующий элемент, обновляем значение получаемое из peek();
     * {@code false} нету следующего элемента, остаемся на текущем элементе
     * @see #hasNext()
     */
    boolean next();


    /**
     * Возвращается на элемент назад
     *
     * @return {@code true} есть элемент, обновляем текущий элемент, получаемый из peek();
     * {@code false} нету элемента на которой можно вернуться, остаемся на текущем элементе
     *
     * @see #hasPrevious()
     */
    boolean previous();

    /**
     * Выполняет переход по указанному индексу элемента
     *
     * @param index индекс элемента на который перейдет текущий элемент (peek());
     * @return получилось ли перейти на указанный элемент {@code true} получилось, обновляем текущий элемент
     * {@code false} не получилось, остаемся на этом же элементе.
     *
     * @throws IllegalArgumentException если index < 0
     */
    boolean goTo(int index);

    /**
     * Проверяет, доступна ли следующий элемент с текущей позиции.
     *
     * @return {@code true} если после текущей позиции есть еще хотя бы один элемент,
     *         {@code false} если в конце текста, нет доступных элементов
     */
    boolean hasNext();

    /**
     * Проверяет доступен ли предыдущий элемент с текущей позиции.
     *
     * @return {@code true}, если есть хотя бы один элемент
     * {@code false}, если нет доступных элементов для перехода
     */
    boolean hasPrevious();

    /**
     * Возвращает содержимое текущего элемента по позиции итератора.
     *
     * @return текущий элемент
     */
    IteratorType peek();

    /**
     * <p><b>Возвращает текущий индекс итератора</b></p>
     */
    int index();

    /**
     * <p><b>Возвращает итератор в исходное состояние.</b></p>
     * <p1>
     * После вызова этого метода индекс итератора вернется на текущие положение
     * После чего используйте {@link #next()} чтобы перейти на следующий элемент
     * из начального положения</p1>
     */
    void reset();
}
